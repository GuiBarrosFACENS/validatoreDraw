@Override
public String processLine(String line) {
    logger.info("Processing line: {}", line);

    String recordType = String.valueOf(line.charAt(7));
    String segmentRecordDetailCode = String.valueOf(line.charAt(13));
    boolean firstLine = SegmentTypeEnum.isT(segmentRecordDetailCode) && actualCount == 0;

    // Verifica se a linha tem exatamente 240 bytes
    if (line.length() != 240) {
        logger.error("Erro: Linha inválida, tamanho incorreto. Esperado 240, mas recebido {}. Linha: {}", line.length(), line);
        // Se a linha for inválida, retorna null e segue para o próximo boleto
        return null;
    }

    if (RecordTypeEnum.isHeader(recordType)) {
        String beneficiaryCode = line.substring(52, 61);
        newLine(RecordTypeEnum.FILE_HEADER.getRecordTypeCode(), beneficiaryCode);
        return null;
    } else if (RecordTypeEnum.isDetail(recordType)) {
        if (firstLine) {
            actualCount++;
            newLine(String.valueOf(actualCount), line);
            return null;
        } else {
            if (SegmentTypeEnum.isT(segmentRecordDetailCode)) {
                // Processando a linha T
                Integer lastCount = actualCount;
                actualCount++;
                newLine(String.valueOf(actualCount), line);
                return null;
            } else if (SegmentTypeEnum.isU(segmentRecordDetailCode)) {
                // Processando a linha U
                if (line.length() != 240) {
                    logger.error("Erro na linha U do boleto {}: tamanho incorreto ({} bytes). Boleto ignorado.", actualCount, line.length());
                    // Se a linha U for inválida, remove a linha T correspondente e ignora esse boleto
                    lineHashMap.remove(String.valueOf(actualCount));
                    return null; // Segue para o próximo boleto sem enviar nada
                }

                // Se ambos T e U forem válidos, constrói o boleto
                String lineBuilded = buildLineByKey(actualCount).toString();
                lineHashMap.remove(String.valueOf(actualCount));
                return lineBuilded;
            } else {
                newLine(String.valueOf(actualCount), line);
                return null;
            }
        }
    } else if (RecordTypeEnum.isBatchTrailer(recordType)) {
        return buildLineByKey(actualCount).toString();
    } else {
        return null;
    }
}


public enum SegmentTypeEnum {
    T("T"),
    U("U");

    private final String code;

    SegmentTypeEnum(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }

    public static boolean isT(String segmentCode) {
        return T.getCode().equals(segmentCode);
    }

    public static boolean isU(String segmentCode) {
        return U.getCode().equals(segmentCode);
    }
}

