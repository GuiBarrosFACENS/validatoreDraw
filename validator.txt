 static final Map<String, Function<BilledInvoiceYK, Object>> fieldAccessors = new HashMap<>();

  static {
    fieldAccessors.put("message", BilledInvoiceYK::getMessage);
    fieldAccessors.put("function", BilledInvoiceYK::getFunction);
    fieldAccessors.put("paymentType", BilledInvoiceYK::getPaymentType);
    fieldAccessors.put("issueDate", BilledInvoiceYK::getIssueDate);
    fieldAccessors.put("paymentDate", BilledInvoiceYK::getPaymentDate);
    fieldAccessors.put("bankCode", BilledInvoiceYK::getBankCode);
    fieldAccessors.put("paymentChannel", BilledInvoiceYK::getPaymentChannel);
    fieldAccessors.put("paymentKind", BilledInvoiceYK::getPaymentKind);
    fieldAccessors.put("covenant", BilledInvoiceYK::getCovenant);
    fieldAccessors.put("typeOfPersonAgreement", BilledInvoiceYK::getTypeOfPersonAgreement);
    fieldAccessors.put("agreementDocument", BilledInvoiceYK::getAgreementDocument);
    fieldAccessors.put("clientNumber", BilledInvoiceYK::getClientNumber);
    fieldAccessors.put("txId", BilledInvoiceYK::getTxId);
    fieldAccessors.put("payerDocumentType", BilledInvoiceYK::getPayerDocumentType);
    fieldAccessors.put("payerDocumentNumber", BilledInvoiceYK::getPayerDocumentNumber);
    fieldAccessors.put("payerName", BilledInvoiceYK::getPayerName);
    fieldAccessors.put("dueDate", BilledInvoiceYK::getDueDate);
  }

  public static Map<String, String> validateFields(BilledInvoiceYK billedInvoiceYK) {
    Map<String, String> invalidFields = new HashMap<>();

    if (!billedInvoiceYK.isPayd()) {
      invalidFields.put("payedValue", "cannot be null or empty!");
    }

    for (Map.Entry<String, Function<BilledInvoiceYK, Object>> entry : fieldAccessors.entrySet()) {
      String fieldName = entry.getKey();
      Object fieldValue = entry.getValue().apply(billedInvoiceYK);

      if (isNullOrEmpty(fieldValue)) {
        invalidFields.put(fieldName, String.format("%s cannot be null or empty!", fieldName));
      }
    }

    return invalidFields;
  }

  private static boolean isNullOrEmpty(Object value) {
    if (value == null) {
      return true;
    }
    if (value instanceof String) {
      return ((String) value).trim().isEmpty();
    }
    if (value instanceof BigDecimal) {
      return ((BigDecimal) value).compareTo(BigDecimal.ZERO) <= 0;
    }
    return false;
  }


@ExtendWith(MockitoExtension.class)
@ActiveProfiles("teste")
class WhitelistValidationTest {

  @InjectMocks private WhitelistValidation whitelistValidation;

  private BilledInvoiceYK billedInvoiceYK;

  @BeforeEach
  void setUp() throws IOException {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper = Mockito.spy(objectMapper);
    billedInvoiceYK =
        objectMapper.readValue(
            new File("src/test/resources/json/billedInvoiceYK.json"), BilledInvoiceYK.class);
  }

  @Test
  public void testValidateFields_AllField() {
    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);
    assertTrue(invalidFields.isEmpty(), "cannot be null or empty!");
  }

  @Test
  public void testValidateFields_UnpaidInvoice() {
    billedInvoiceYK.setPayd(false);
    billedInvoiceYK.setPayedValue(BigDecimal.ZERO);

    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(invalidFields.isEmpty(), "Expected invalid fields for unpaid invoice");
    assertTrue(
        invalidFields.containsKey("payedValue"), "Missing field error expected for payedValue");
  }

  @Test
  public void testValidateFields_EmptyRequiredField() {
    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));
    billedInvoiceYK.setMessage("");

    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(invalidFields.isEmpty(), "Expected invalid fields for empty required field");
    assertTrue(invalidFields.containsKey("message"), "Missing field error expected for message");
  }

  @Test
  void testValidateFields_NullFields() {
    billedInvoiceYK.setMessage(null);
    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);
    assertTrue(invalidFields.containsKey("message"));
  }

    @Test
    public void testIsNullOrEmpty_BigDecimalZero() {
        billedInvoiceYK.setPayedValue(BigDecimal.ZERO);

        Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

        assertTrue(invalidFields.containsKey("payedValue"), "payedValue zero should be considered invalid");
    }

    @Test
    public void testIsNullOrEmpty_BigDecimalPositive() {
        billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));

        Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

        assertFalse(invalidFields.containsKey("payedValue"), "payedValue greater than zero should be considered valid");
    }

    @Test
    public void testIsNullOrEmpty_NonStringNonBigDecimal() {
        // Adding a test for a field that is neither String nor BigDecimal
        Map<String, Function<BilledInvoiceYK, Object>> fieldAccessorsBackup = new HashMap<>(WhitelistValidation.fieldAccessors);
        
        WhitelistValidation.fieldAccessors.put("nonStandardField", billedInvoice -> new Object());

        billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));

        Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

        // Ensure that no invalid fields are returned for non-String and non-BigDecimal fields
        assertFalse(invalidFields.containsKey("nonStandardField"), "nonStandardField should not be considered invalid");

        // Restore the original fieldAccessors
        WhitelistValidation.fieldAccessors = fieldAccessorsBackup;
    }







@Test
public void testValidateFields_BigDecimalLessThanOrEqualToZero() {
    // Setting BigDecimal fields to zero and negative value
    billedInvoiceYK.setPayedValue(BigDecimal.ZERO);
    billedInvoiceYK.setBankCode(BigDecimal.valueOf(-1));

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    // Verifying that the invalidFields map contains the keys with the BigDecimal values that are <= 0
    assertTrue(invalidFields.containsKey("payedValue"), "Expected invalid field for payedValue");
    assertTrue(invalidFields.containsKey("bankCode"), "Expected invalid field for bankCode");
}

@Test
public void testValidateFields_BigDecimalGreaterThanZero() {
    // Setting BigDecimal fields to values greater than zero
    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));
    billedInvoiceYK.setBankCode(BigDecimal.valueOf(1));

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    // Verifying that the invalidFields map does not contain the keys with the BigDecimal values that are > 0
    assertFalse(invalidFields.containsKey("payedValue"), "Did not expect invalid field for payedValue");
    assertFalse(invalidFields.containsKey("bankCode"), "Did not expect invalid field for bankCode");
}
