
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class KafkaWriterCustom implements ItemWriter<InvoicePaymentPlard> {

  private final InvoiceCnabBatchProperties pocSpringBatchProperties;

  private final KafkaTemplate<String, InvoicePaymentPlard> kafkaTemplate;

  public KafkaWriterCustom(InvoiceCnabBatchProperties pocSpringBatchProperties, KafkaTemplate<String, InvoicePaymentPlard> kafkaTemplate) {
    this.pocSpringBatchProperties = pocSpringBatchProperties;
    this.kafkaTemplate = kafkaTemplate;
  }


  @Override
  public void write(Chunk<? extends InvoicePaymentPlard> chunk) throws Exception {
    chunk.forEach(invoicePaymentPlard -> {
      ProducerRecord<String,InvoicePaymentPlard> producerRecord = new ProducerRecord(this.pocSpringBatchProperties.getPlardTopic(),invoicePaymentPlard);
      kafkaTemplate.send(producerRecord);
    });
  }
}

classe a ser testada


import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Component;

/** App arsenal provider impl. */
@Component
@AllArgsConstructor
@Slf4j
public class KafkaProviderImpl implements KafkaProvider {

  private final KafkaTemplate<String, String> kafkaTemplate;
  private final InvoicePaymentYkProperties invoicePaymentYkProperties;
  private final ObjectMapper objectMapper;

  @Retryable(retryFor = ErrorSendTopicKafkaException.class, maxAttempts = 5)
  public void sendTopic(BilledInvoicePlard billedInvoicePlard) {
    try {
      String messageBody = objectMapper.writeValueAsString(billedInvoicePlard);
      this.sendMessage(messageBody);
    } catch (Exception e) {
      throw new ErrorSendTopicKafkaException(
          String.valueOf(billedInvoicePlard.getTransactionNsu()), e);
    }
  }

  private void sendMessage(String messageBody) {
    kafkaTemplate
        .send(invoicePaymentYkProperties.getPlardTopic(), messageBody)
        .thenApply(
            result -> {
              log.debug(
                  "Sent message= {} with offset= {}",
                  messageBody,
                  result.getRecordMetadata().offset());
              return result;
            });
  }
}

classe exemplo que já está sendo testada

import java.io.File;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import org.apache.commons.io.FileUtils;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.common.TopicPartition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.KafkaException;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.util.ResourceUtils;
import org.springframework.util.StringUtils;

@ActiveProfiles("test")
@ExtendWith(MockitoExtension.class)
class KafkaProviderImplTest {

  private static final String TOPIC_KAFKA = "topic-example.v1.out";

  private String jsonExpected;

  private BilledInvoicePlard invoicePlardExpected;

  private ObjectMapper objectMapper;

  private KafkaProviderImpl kafkaProvider;

  @Mock private KafkaTemplate<String, String> kafkaTemplate;

  @BeforeEach
  public void initializeMocks() throws IOException {
    initializeObjectMapper();
    initializeKafkaProvider();
    initializeExpectedObjects();
  }

  private void initializeObjectMapper() {
    ObjectMapper objectMapper = new InvoicePaymentYkConfig().objectMapper();
    this.objectMapper = Mockito.spy(objectMapper);
  }

  private void initializeKafkaProvider() {
    InvoicePaymentYkProperties invoicePaymentYkProperties = new InvoicePaymentYkProperties();
    invoicePaymentYkProperties.setPlardTopic(TOPIC_KAFKA);
    kafkaProvider =
        new KafkaProviderImpl(kafkaTemplate, invoicePaymentYkProperties, this.objectMapper);
  }

  private void initializeExpectedObjects() throws IOException {
    File file = ResourceUtils.getFile("src/test/resources/json/billet-invoice-plard.json");
    jsonExpected = StringUtils.trimAllWhitespace(FileUtils.readFileToString(file));
    invoicePlardExpected = objectMapper.readValue(jsonExpected, BilledInvoicePlard.class);
  }

  @Test
  void sendTopicSuccessfully() {
    CompletableFuture<SendResult<String, String>> result = mockCompletableFuture();
    Mockito.when(kafkaTemplate.send(TOPIC_KAFKA, jsonExpected)).thenReturn(result);
    Assertions.assertDoesNotThrow(() -> kafkaProvider.sendTopic(invoicePlardExpected));
    verify(kafkaTemplate, Mockito.times(1)).send(TOPIC_KAFKA, jsonExpected);
  }

  private CompletableFuture<SendResult<String, String>> mockCompletableFuture() {
    ProducerRecord<String, String> producerRecord = new ProducerRecord<>(TOPIC_KAFKA, jsonExpected);
    TopicPartition topicPartition = new TopicPartition(TOPIC_KAFKA, 0);
    RecordMetadata recordMetadata = new RecordMetadata(topicPartition, 0, 0, 0, 0, 0);
    SendResult<String, String> result = new SendResult<>(producerRecord, recordMetadata);
    return CompletableFuture.completedFuture(result);
  }

  @Test
  void sendTopicInterruptedException() {
    Mockito.when(kafkaTemplate.send(TOPIC_KAFKA, jsonExpected))
        .thenThrow(new RuntimeException(new InterruptedException()));
    Assertions.assertThrows(
        ErrorSendTopicKafkaException.class, () -> kafkaProvider.sendTopic(invoicePlardExpected));
    verify(kafkaTemplate, Mockito.times(1)).send(TOPIC_KAFKA, jsonExpected);
  }

  @Test
  void sendTopicKafkaExceptionAsync() {
    CompletableFuture<SendResult<String, String>> result = mockCompletableFutureException();
    Mockito.when(kafkaTemplate.send(TOPIC_KAFKA, jsonExpected)).thenReturn(result);
    Assertions.assertDoesNotThrow(() -> kafkaProvider.sendTopic(invoicePlardExpected));
    verify(kafkaTemplate, Mockito.times(1)).send(TOPIC_KAFKA, jsonExpected);
  }

  @Test
  void sendTopicJsonProcessingException() throws JsonProcessingException {
    Mockito.when(objectMapper.writeValueAsString(invoicePlardExpected))
        .thenThrow(JsonProcessingException.class);
    Assertions.assertThrows(
        ErrorSendTopicKafkaException.class, () -> kafkaProvider.sendTopic(invoicePlardExpected));
    verify(kafkaTemplate, Mockito.never()).send(TOPIC_KAFKA, jsonExpected);
  }

  private CompletableFuture<SendResult<String, String>> mockCompletableFutureException() {
    return CompletableFuture.failedFuture(new KafkaException("Error to send kafka message"));
  }


primeiro teste 


import java.io.File;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.kafka.KafkaException;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.util.ResourceUtils;
import org.springframework.util.StringUtils;

@SpringBootTest
@ActiveProfiles("test")
class KafkaProviderImplRetryableTest {

  private static final String TOPIC_KAFKA = "topic-example.v1.out";

  @MockBean private KafkaTemplate<String, String> kafkaTemplate;

  @Autowired private KafkaProviderImpl kafkaProvider;

  @Autowired private ObjectMapper objectMapper;

  private String jsonExpected;

  private BilledInvoicePlard invoicePlard;

  @BeforeEach
  void initialize() throws IOException {
    File file = ResourceUtils.getFile("src/test/resources/json/billet-invoice-plard.json");
    jsonExpected = StringUtils.trimAllWhitespace(FileUtils.readFileToString(file));
    invoicePlard = objectMapper.readValue(jsonExpected, BilledInvoicePlard.class);
  }

  @Test
  void sendTopicFiveTimes() {
    CompletableFuture<SendResult<String, String>> result = mockCompletableFutureException();
    Mockito.when(kafkaTemplate.send(TOPIC_KAFKA, jsonExpected)).thenReturn(result);
    Assertions.assertThrows(
        ErrorSendTopicKafkaException.class, () -> kafkaProvider.sendTopic(invoicePlard));
    verify(kafkaTemplate, Mockito.times(5)).send(Mockito.any(), Mockito.any());
  }

  private CompletableFuture<SendResult<String, String>> mockCompletableFutureException() {
    return CompletableFuture.failedFuture(new KafkaException("Error to send kafka message"));
  }
  
  
  segundo teste 
  
  teste de integração 
  
  
  @ActiveProfiles("test")
@RunWith(SpringRunner.class)
@SpringBootTest
@EmbeddedKafka(
    partitions = 1,
    brokerProperties = {"listeners=PLAINTEXT://localhost:9092", "port=9092"})
class KafkaProviderImplTest {

  @Autowired private KafkaConsumerProviderImpl consumer;

  @Autowired private WebhookApiController webhookApiController;

  @Test
  @Disabled("Teste desabilitado devido a dependencia do kafka na pipeline")
  void sendTopic() throws InterruptedException {
    WebhookRequestDTO webhookRequestDTO = new WebhookRequestDTO();
    webhookApiController.create(webhookRequestDTO);
    consumer.getLatch().await(3L, TimeUnit.SECONDS);
    Assertions.assertEquals(0, consumer.getLatch().getCount());
  }
}


inicio dela


import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class KafkaWriterCustomTest {

    @BeforeEach
    void setUp() {
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    void write() {
    }
}


-----------------


import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.test.context.EmbeddedKafka;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.util.concurrent.CountDownLatch;

import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ActiveProfiles("test")
@SpringBootTest
@EmbeddedKafka(partitions = 1, topics = {"topic-example.v1.out"})
class KafkaWriterCustomIntegrationTest {

    @Autowired
    private KafkaTemplate<String, InvoicePaymentPlard> kafkaTemplate;

    @Autowired
    private InvoiceCnabBatchProperties properties;

    private KafkaWriterCustom kafkaWriterCustom;

    private CountDownLatch latch = new CountDownLatch(1);

    private InvoicePaymentPlard receivedInvoicePaymentPlard;

    @BeforeEach
    void setUp() {
        kafkaWriterCustom = new KafkaWriterCustom(properties, kafkaTemplate);
    }

    @KafkaListener(topics = "topic-example.v1.out", groupId = "test-group")
    public void listen(ConsumerRecord<String, InvoicePaymentPlard> record) {
        receivedInvoicePaymentPlard = record.value();
        latch.countDown();
    }

    @Test
    void write() throws Exception {
        InvoicePaymentPlard invoicePaymentPlard = new InvoicePaymentPlard();
        kafkaWriterCustom.write(List.of(invoicePaymentPlard));

        latch.await(10, TimeUnit.SECONDS);

        assertEquals(invoicePaymentPlard, receivedInvoicePaymentPlard);
    }
}

----

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.SettableListenableFuture;

import java.util.List;

import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

@SpringJUnitConfig
@ExtendWith({SpringExtension.class, MockitoExtension.class})
class KafkaWriterCustomTest {

    @Mock
    private InvoiceCnabBatchProperties properties;

    @Mock
    private KafkaTemplate<String, InvoicePaymentPlard> kafkaTemplate;

    private KafkaWriterCustom kafkaWriterCustom;

    @BeforeEach
    void setUp() {
        Mockito.when(properties.getPlardTopic()).thenReturn("topic-example.v1.out");
        kafkaWriterCustom = new KafkaWriterCustom(properties, kafkaTemplate);
    }

    @Test
    void write() throws Exception {
        InvoicePaymentPlard invoicePaymentPlard = new InvoicePaymentPlard();
        List<InvoicePaymentPlard> items = List.of(invoicePaymentPlard);

        // Mock the send method of kafkaTemplate
        SettableListenableFuture<SendResult<String, InvoicePaymentPlard>> future = new SettableListenableFuture<>();
        future.set(null);
        Mockito.when(kafkaTemplate.send(Mockito.any(ProducerRecord.class))).thenReturn(future);

        kafkaWriterCustom.write(items);

        verify(kafkaTemplate, times(1)).send(Mockito.any(ProducerRecord.class));
    }

    @Test
    void writeEmptyChunk() throws Exception {
        List<InvoicePaymentPlard> items = List.of();

        kafkaWriterCustom.write(items);

        verify(kafkaTemplate, times(0)).send(Mockito.any(ProducerRecord.class));
    }
}

---

java.lang.ClassCastException: class java.util.ImmutableCollections$ListN cannot be cast to class org.springframework.batch.item.Chunk (java.util.ImmutableCollections$ListN is in module java.base of loader 'bootstrap'; org.springframework.batch.item.Chunk is in unnamed module of loader 'app')

	at com.santander.mpa.infra.messageprovider.KafkaWriterCustomTest.writeEmptyChunk(KafkaWriterCustomTest.java:65)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
