import com.santander.mpa.domain.entity.BilledInvoiceYK;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

public class WhitelistValidation {

  static Map<String, Function<BilledInvoiceYK, Object>> fieldAccessors = new HashMap<>();

  static {
    fieldAccessors.put("message", BilledInvoiceYK::getMessage);
    fieldAccessors.put("function", BilledInvoiceYK::getFunction);
    fieldAccessors.put("paymentType", BilledInvoiceYK::getPaymentType);
    fieldAccessors.put("issueDate", BilledInvoiceYK::getIssueDate);
    fieldAccessors.put("paymentDate", BilledInvoiceYK::getPaymentDate);
    fieldAccessors.put("bankCode", BilledInvoiceYK::getBankCode);
    fieldAccessors.put("paymentChannel", BilledInvoiceYK::getPaymentChannel);
    fieldAccessors.put("paymentKind", BilledInvoiceYK::getPaymentKind);
    fieldAccessors.put("covenant", BilledInvoiceYK::getCovenant);
    fieldAccessors.put("typeOfPersonAgreement", BilledInvoiceYK::getTypeOfPersonAgreement);
    fieldAccessors.put("agreementDocument", BilledInvoiceYK::getAgreementDocument);
    fieldAccessors.put("clientNumber", BilledInvoiceYK::getClientNumber);
    fieldAccessors.put("txId", BilledInvoiceYK::getTxId);
    fieldAccessors.put("payerDocumentType", BilledInvoiceYK::getPayerDocumentType);
    fieldAccessors.put("payerDocumentNumber", BilledInvoiceYK::getPayerDocumentNumber);
    fieldAccessors.put("payerName", BilledInvoiceYK::getPayerName);
    fieldAccessors.put("dueDate", BilledInvoiceYK::getDueDate);
  }

  public static Map<String, String> validateFields(BilledInvoiceYK billedInvoiceYK) {
    Map<String, String> invalidFields = new HashMap<>();

    if (!billedInvoiceYK.isPayd()) {
      invalidFields.put("payedValue", "cannot be null or empty!");
    }

    for (Map.Entry<String, Function<BilledInvoiceYK, Object>> entry : fieldAccessors.entrySet()) {
      String fieldName = entry.getKey();
      Object fieldValue = entry.getValue().apply(billedInvoiceYK);

      if (isNullOrEmpty(fieldValue)) {
        invalidFields.put(fieldName, String.format("%s cannot be null or empty!", fieldName));
      }
    }

    return invalidFields;
  }

  private static boolean isNullOrEmpty(Object value) {
    if (value == null) {
      return true;
    }
    if (value instanceof String) {
      return ((String) value).trim().isEmpty();
    }
    if (value instanceof BigDecimal) {
      return ((BigDecimal) value).compareTo(BigDecimal.ZERO) <= 0;
    }
    return false;
  }
}

------------


import com.fasterxml.jackson.databind.ObjectMapper;
import com.santander.mpa.domain.entity.BilledInvoiceYK;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.context.ActiveProfiles;

@ExtendWith(MockitoExtension.class)
@ActiveProfiles("teste")
class WhitelistValidationTest {

  @InjectMocks private WhitelistValidation whitelistValidation;

  private BilledInvoiceYK billedInvoiceYK;

  @BeforeEach
  void setUp() throws IOException {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper = Mockito.spy(objectMapper);
    billedInvoiceYK =
        objectMapper.readValue(
            new File("src/test/resources/json/billedInvoiceYK.json"), BilledInvoiceYK.class);
  }

  @Test
  public void testValidateFields_AllField() {
    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);
    assertTrue(invalidFields.isEmpty(), "cannot be null or empty!");
  }

  @Test
  public void testValidateFields_UnpaidInvoice() {
    billedInvoiceYK.setPayd(false);
    billedInvoiceYK.setPayedValue(BigDecimal.ZERO);

    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(invalidFields.isEmpty(), "Expected invalid fields for unpaid invoice");
    assertTrue(
        invalidFields.containsKey("payedValue"), "Missing field error expected for payedValue");
  }

  @Test
  public void testValidateFields_EmptyRequiredField() {
    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));
    billedInvoiceYK.setMessage("");

    Map<String, String> invalidFields = whitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(invalidFields.isEmpty(), "Expected invalid fields for empty required field");
    assertTrue(invalidFields.containsKey("message"), "Missing field error expected for message");
  }

  @Test
  void testValidateFields_NullFields() {
    billedInvoiceYK.setMessage(null);
    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);
    assertTrue(invalidFields.containsKey("message"));
  }

  @Test
  public void testIsNullOrEmpty_BigDecimalZero() {
    billedInvoiceYK.setPayedValue(BigDecimal.ZERO);

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    assertTrue(
        invalidFields.containsKey("payedValue"), "payedValue zero should be considered invalid");
  }

  @Test
  public void testIsNullOrEmpty_BigDecimalPositive() {
    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(
        invalidFields.containsKey("payedValue"),
        "payedValue greater than zero should be considered valid");
  }

  @Test
  public void testIsNullOrEmpty_NonStringNonBigDecimal() {
    Map<String, Function<BilledInvoiceYK, Object>> fieldAccessorsBackup =
        new HashMap<>(WhitelistValidation.fieldAccessors);
    WhitelistValidation.fieldAccessors.put("nonStandardField", billedInvoice -> new Object());

    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));
    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);
    assertFalse(
        invalidFields.containsKey("nonStandardField"),
        "nonStandardField should not be considered invalid");

    WhitelistValidation.fieldAccessors = fieldAccessorsBackup;
  }

  @Test
  public void testValidateFields_BigDecimalLessThanOrEqualToZero() {
    billedInvoiceYK.setPayedValue(BigDecimal.ZERO);
    billedInvoiceYK.setBankCode(BigDecimal.valueOf(-1));

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    assertTrue(invalidFields.containsKey("payedValue"), "Expected invalid field for payedValue");
    assertTrue(invalidFields.containsKey("bankCode"), "Expected invalid field for bankCode");
  }

  @Test
  public void testValidateFields_BigDecimalGreaterThanZero() {
    billedInvoiceYK.setPayedValue(BigDecimal.valueOf(1));
    billedInvoiceYK.setBankCode(BigDecimal.valueOf(1));

    Map<String, String> invalidFields = WhitelistValidation.validateFields(billedInvoiceYK);

    assertFalse(
        invalidFields.containsKey("payedValue"), "Did not expect invalid field for payedValue");
    assertFalse(invalidFields.containsKey("bankCode"), "Did not expect invalid field for bankCode");
  }
}


-------------------


import java.util.Map;

public class ValidateBilledInvoiceYKCommand {

  public void execute(BilledInvoiceYK billedInvoiceYK) {
    Map<String, String> constrainsViolation = WhitelistValidation.validateFields(billedInvoiceYK);
    if (!constrainsViolation.isEmpty()) {
      throw new ValidationException(createMessage(constrainsViolation));
    }
  }

  private String createMessage(Map<String, String> constrainsViolation) {
    StringBuilder message = new StringBuilder();
    constrainsViolation.forEach(
        // Field 'bankCode' is value 'bankCode cannot be null or empty!
        (key, value) -> message.append(String.format("'%s' %n ", value)));
    return message.toString();
  }
