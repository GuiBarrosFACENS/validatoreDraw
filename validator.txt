package com.santander.mpa.domain.enums;

public enum SegmentTypeEnum {
    T, U, Y;

    public static boolean isT(String segmentCode) {
        return T.name().equals(segmentCode);
    }

    public static boolean isU(String segmentCode) {
        return U.name().equals(segmentCode);
    }

    public static boolean isY(String segmentCode) {
        return Y.name().equals(segmentCode);
    }
}



package com.santander.mpa.domain.enums;

public enum RecordTypeEnum {
    FILE_HEADER("0"),
    BATCH_HEADER("1"),
    DETAIL("3"),
    BATCH_TRAILER("5"),
    FILE_TRAILER("9");

    private final String recordTypeCode;

    RecordTypeEnum(String recordTypeCode) {
        this.recordTypeCode = recordTypeCode;
    }

    public String getRecordTypeCode() {
        return recordTypeCode;
    }

    public static boolean isHeader(String recordTypeCode) {
        return FILE_HEADER.recordTypeCode.equals(recordTypeCode);
    }

    public static boolean isDetail(String recordTypeCode) {
        return DETAIL.recordTypeCode.equals(recordTypeCode);
    }

    public static boolean isBatchTrailer(String recordTypeCode) {
        return BATCH_TRAILER.recordTypeCode.equals(recordTypeCode);
    }

    public static boolean isFileTrailer(String recordTypeCode) {
        return FILE_TRAILER.recordTypeCode.equals(recordTypeCode);
    }
}



package com.santander.mpa.domain.usecase.impl;

import com.santander.mpa.domain.enums.RecordTypeEnum;
import com.santander.mpa.domain.enums.SegmentTypeEnum;
import com.santander.mpa.domain.usecase.FileSegmentsBuilderUseCase;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class FileSegmentsBuilderUseCaseImpl implements FileSegmentsBuilderUseCase {

    private static final Logger logger = LoggerFactory.getLogger(FileSegmentsBuilderUseCaseImpl.class);
    private final Map<String, List<String>> lineHashMap = new HashMap<>();
    private Integer actualCount = 0;

    @Override
    public String processLine(String line) {
        logger.info("Processing line: {}", line);

        if (line.length() != 240) {
            logger.error("Erro: Linha invÃ¡lida, tamanho incorreto. Esperado 240, mas recebido {}. Linha: {}", line.length(), line);
            return null;
        }

        String recordType = String.valueOf(line.charAt(7));
        String segmentCode = String.valueOf(line.charAt(13));

        if (RecordTypeEnum.isHeader(recordType)) {
            String beneficiaryCode = line.substring(52, 61);
            newLine(RecordTypeEnum.FILE_HEADER.getRecordTypeCode(), beneficiaryCode);
            return null;
        }

        if (RecordTypeEnum.isDetail(recordType)) {
            if (SegmentTypeEnum.isT(segmentCode) && actualCount == 0) {
                actualCount++;
                newLine(String.valueOf(actualCount), line);
                return null;
            }

            if (SegmentTypeEnum.isT(segmentCode)) {
                actualCount++;
                newLine(String.valueOf(actualCount), line);
                return null;
            }

            if (SegmentTypeEnum.isU(segmentCode)) {
                if (line.length() != 240) {
                    logger.error("Erro na linha U do boleto {}: tamanho incorreto ({} bytes). Boleto ignorado.", actualCount, line.length());
                    lineHashMap.remove(String.valueOf(actualCount));
                    return null;
                }

                String completedLine = buildLineByKey(actualCount).toString();
                lineHashMap.remove(String.valueOf(actualCount));
                return completedLine;
            }

            newLine(String.valueOf(actualCount), line);
        } else if (RecordTypeEnum.isBatchTrailer(recordType)) {
            return buildLineByKey(actualCount).toString();
        }

        return null;
    }

    @Override
    public StringBuilder build() {
        StringBuilder fileLines = new StringBuilder();

        String beneficiaryCode = lineHashMap.get(RecordTypeEnum.FILE_HEADER.getRecordTypeCode()).get(0);
        lineHashMap.forEach((key, value) -> {
            if (RecordTypeEnum.isHeader(key)) return;

            StringBuilder line = new StringBuilder();
            value.forEach(line::append);
            line.append(beneficiaryCode).append("\n");

            fileLines.append(line);
        });

        return fileLines;
    }

    private StringBuilder buildLineByKey(Integer key) {
        List<String> lines = lineHashMap.get(String.valueOf(key));
        String beneficiaryCode = lineHashMap.get(RecordTypeEnum.FILE_HEADER.getRecordTypeCode()).get(0);

        StringBuilder line = new StringBuilder();
        lines.forEach(line::append);
        line.append(beneficiaryCode).append("\n");

        return line;
    }

    private void newLine(String lineNumber, String line) {
        lineHashMap.computeIfAbsent(lineNumber, k -> new ArrayList<>()).add(line);
    }

    public Map<String, List<String>> getLineHashMap() {
        return lineHashMap;
    }
}

