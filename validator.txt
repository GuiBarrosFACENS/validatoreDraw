package com.santander.mpa.domain.usecase.impl;

import com.santander.mpa.domain.enums.RecordTypeEnum;
import com.santander.mpa.domain.enums.SegmentTypeEnum;
import com.santander.mpa.domain.usecase.FileSegmentsBuilderUseCase;
import java.nio.charset.StandardCharsets;
import java.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileSegmentsBuilderUseCaseImpl implements FileSegmentsBuilderUseCase {

    private static final Logger logger = LoggerFactory.getLogger(FileSegmentsBuilderUseCaseImpl.class);
    private final Map<String, List<String>> lineHashMap = new HashMap<>();
    private Integer actualCount = 0;

    @Override
    public String processLine(String line) {
        logger.info("Processing line: {}", line);

        String recordType = String.valueOf(line.charAt(7));
        String segmentRecordDetailCode = String.valueOf(line.charAt(13));
        boolean firstLine = SegmentTypeEnum.isT(segmentRecordDetailCode) && actualCount == 0;

        // Verifica se a linha tem exatamente 240 bytes
        if (line.getBytes(StandardCharsets.UTF_8).length != 240) {
            logger.error("Erro: Linha inválida, tamanho incorreto. Esperado 240 bytes, mas recebido {} bytes. Linha: {}", line.getBytes(StandardCharsets.UTF_8).length, line);
            // Se a linha for inválida, retorna null e segue para o próximo boleto
            return null;
        }

        if (RecordTypeEnum.isHeader(recordType)) {
            String beneficiaryCode = line.substring(52, 61);
            newLine(RecordTypeEnum.FILE_HEADER.getRecordTypeCode(), beneficiaryCode);
            return null;
        } else if (RecordTypeEnum.isDetail(recordType)) {
            if (firstLine) {
                actualCount++;
                newLine(String.valueOf(actualCount), line);
                return null;
            } else {
                if (SegmentTypeEnum.isT(segmentRecordDetailCode)) {
                    // Processando a linha T
                    Integer lastCount = actualCount;
                    actualCount++;
                    newLine(String.valueOf(actualCount), line);
                    return null;
                } else if (SegmentTypeEnum.isU(segmentRecordDetailCode)) {
                    // Processando a linha U
                    if (line.getBytes(StandardCharsets.UTF_8).length != 240) {
                        logger.error("Erro na linha U do boleto {}: tamanho incorreto ({} bytes). Boleto ignorado.", actualCount, line.getBytes(StandardCharsets.UTF_8).length);
                        // Se a linha U for inválida, remove a linha T correspondente e ignora esse boleto
                        lineHashMap.remove(String.valueOf(actualCount));
                        return null; // Segue para o próximo boleto sem enviar nada
                    }

                    // Se ambos T e U forem válidos, constrói o boleto
                    String lineBuilded = buildLineByKey(actualCount).toString();
                    lineHashMap.remove(String.valueOf(actualCount));
                    return lineBuilded;
                } else {
                    newLine(String.valueOf(actualCount), line);
                    return null;
                }
            }
        } else if (RecordTypeEnum.isBatchTrailer(recordType)) {
            return buildLineByKey(actualCount).toString();
        } else {
            return null;
        }
    }

    @Override
    public StringBuilder build() {
        StringBuilder fileLines = new StringBuilder();

        String beneficiaryCode = lineHashMap.get(RecordTypeEnum.FILE_HEADER.getRecordTypeCode()).get(0);
        lineHashMap.forEach(
            (key, value) -> {
                if (RecordTypeEnum.isHeader(key)) return;

                StringBuilder line = new StringBuilder();
                value.forEach(line::append);
                line.append(beneficiaryCode);
                line.append("\n");

                fileLines.append(line);
            }
        );

        return fileLines;
    }

    private StringBuilder buildLineByKey(Integer key) {
        String beneficiaryCode = lineHashMap.get(RecordTypeEnum.FILE_HEADER.getRecordTypeCode()).get(0);

        List<String> linesByKey = lineHashMap.get(String.valueOf(key));

        if (linesByKey == null) {
            logger.error("Erro: Não encontrado linhas para a chave {}", key);
            return new StringBuilder(); // Retorna uma StringBuilder vazia se não encontrar linhas
        }

        StringBuilder line = new StringBuilder();
        linesByKey.forEach(line::append);
        line.append(beneficiaryCode);
        line.append("\n");

        return line;
    }

    private void newLine(String lineNumber, String line) {
        lineHashMap.computeIfAbsent(lineNumber, k -> new ArrayList<>()).add(line);
    }

    public Map<String, List<String>> getLineHashMap() {
        return lineHashMap;
    }
}
